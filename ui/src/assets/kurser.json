{
  "ISGB04": [
    {
      "Förklara skillnaderna mellan följande koncept och ge exempel på användningsområden: \na) Call by value vs Call by reference i C \nb) Strukturerad vs Objektorienterad programmering \nc) Statisk vs Dynamisk minnesallokering": "Call by value skickar en kopia av värdet till funktionen och ändringar påverkar inte originalvariabeln. Call by reference skickas via pekare så att funktionen kan ändra originalvärdet direkt. \n\nStrukturerad programmering bygger på procedurer och separerar data och funktioner, medan objektorienterad programmering kapslar in data och metoder i objekt och använder arv, polymorfism och inkapsling. \n\nStatisk minnesallokering bestämmer minnesstorleken vid kompilering eller funktionsstart, medan dynamisk minnesallokering bestämmer storleken under körning och kräver att programmeraren frigör minnet manuellt."
    },
    {
      "Vad blir utskriften av följande C-program?\n\n#include <stdio.h>\nvoid funk(int *x) {\n    *x = *x + 2;\n    printf(\"%i \",*x)\n;}\n\nint main() {\n    int a = 5;\n    printf(\"%i\", a);\n    funk(&a);\n   printf(\"%i\", a);\nreturn 0\n;}": "5 (Först skrivs a ut.)\n7 (Inne i funk använder pekaren *x adressen för att ändra a från 5 till 7. Detta nya värde skrivs ut.)\n7 (Slutligen skrivs det nu uppdaterade värdet på a ut igen i main.)\n"
    },
    {
      "Implementera en funktion i C som tar en array av heltal och dess storlek som parametrar. \nFunktionen ska returnera summan av alla jämna tal i arrayen. Inkludera även ett huvudprogram som testar funktionen.": "int sum_even_numbers(int arr[], int size) {\n    int sum = 0;\n\n    for (int i = 0; i < size; i++) {\n        if (arr[i] % 2 == 0) {\n                sum += arr[i];\n        }\n   }\nreturn sum;\n}\n\nint main() {\n\n   int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n\n    int even_sum = sum_even_numbers(numbers, size);\n\n   printf(\"Summan av alla jämna tal i arrayen är: %d\", even_sum);\n\nreturn 0;\n}"
    },
    {
      "Du är projektledare för ett team som ska utveckla ett nytt bibliotekssystem. Beskriv:\na) Vilka intressenter skulle du identifiera?": "a)\nBiblioteksanvändare: De som lånar och returnerar böcker. De har krav på användarvänlighet, sökningsfunktioner och tillgång till sitt lånekonto.\n\nBibliotekspersonal: De som hanterar utlåning, återlämning, inköp av böcker och administration. Deras behov inkluderar ett effektivt och robust system för dagliga arbetsflöden.\n\nBiblioteksledning/chefer: De som ansvarar för budget, beslutsfattande och övergripande strategi. De vill se en kostnadseffektiv lösning som kan ge rapporter och statistik.\n\nSystemutvecklingsteam: De som bygger systemet. De är intresserade av tydliga krav, teknisk genomförbarhet och en effektiv utvecklingsprocess.\n\nLeverantörer av befintliga system: Om det finns befintliga system som ska ersättas eller integreras, kan leverantörerna vara intressenter.\n\nFinansiärer/ägare: De som står för den ekonomiska investeringen. De vill ha en avkastning på sin investering och att projektet levererar enligt budget."
    },
    {
      "Du är projektledare för ett team som ska utveckla ett nytt bibliotekssystem. Beskriv:\nb) Vilka huvudsakliga risker ser du med projektet?": "b)\nTeknisk risk: Det kan uppstå oväntade tekniska utmaningar, till exempel problem med integration mot befintliga system, datamigrering från det gamla systemet eller prestandaproblem när många användare är inloggade samtidigt.\n\nTids- och budgetrisk: Projektet kan dra ut på tiden och överskrida budgeten på grund av orealistiska tidsuppskattningar, kravförändringar under projektets gång eller resursbrist.\n\nAnvändaracceptans: Om systemet inte är intuitivt eller uppfyller bibliotekspersonalens och användarnas behov, kan det leda till låg acceptans. Detta kan kräva omfattande omdesign och mer utbildning, vilket i sin tur leder till ökade kostnader och förseningar.\n\nDatasäkerhets- och integritetsrisk: Bibliotekssystem hanterar personuppgifter. En risk är att systemet inte uppfyller lagkrav (t.ex. GDPR) eller att det finns säkerhetsbrister som kan leda till dataläckage."
    },
    {
      "Diskutera för- och nackdelar med Vattenfallsmodellen samt i vilka situationer den är mest lämplig.": "Vattenfallsmodellen är en traditionell och linjär metod där utvecklingen sker i sekventiella faser. Varje fas måste vara helt slutförd innan nästa påbörjas, likt vatten som faller nedför ett vattenfall.\n\nFaser: Kravanalys → Design → Implementation → Testning → Drift och underhåll.\n\nFördelar:\n   Struktur: Metoden är mycket strukturerad och enkel att förstå.\n    Tydlighet: Krav och planering är tydliga från start, vilket gör det enkelt att hantera resurser och budget.\n   Dokumentation: Omfattande dokumentation skapas i varje fas.\n\nNackdelar:\n   Långsamhet: Oflexibel och långsam. Det är svårt att gå tillbaka och ändra krav när en fas är avslutad.\n    Risk: Risken att systemet inte möter användarens behov är hög, eftersom ingen kundfeedback ges förrän i slutet.\n   Förseningar: Problem som upptäcks sent i processen blir dyra att åtgärda.\n\nLämplig för: Projekt med väldefinierade, stabila krav där förändringar är osannolika. Ofta används den för mindre, väletablerade projekt eller där regelverk kräver en mycket strikt process."
    },
    {
      "Diskutera för- och nackdelar med Spiralmodellen samt i vilka situationer den är mest lämplig.": "Spiralmodellen är en iterativ metod som kombinerar element från vattenfallsmodellen med iterativ utveckling och fokus på riskhantering. Utvecklingen sker i \"spiraler\", där varje varv i spiralen representerar en fas som avslutas med en riskbedömning.\n\nFaser: Planering → Riskbedömning → Utveckling/Prototypning → Utvärdering.\n\nFördelar:\n   Flexibilitet: Modellen är flexibel och tillåter förändringar under projektets gång.\n   Riskhantering: Fokuserar på att identifiera och hantera risker tidigt i processen.\n    Feedback: Prototyper kan presenteras för intressenter för att få feedback.\n\nNackdelar:\n    Komplexitet: Kan vara komplex och kräver erfarenhet av riskhantering.\n   Tidskrävande: De många varven och riskbedömningarna kan göra processen lång.\n    Kostnad: Kan bli dyr om man inte hanterar riskerna effektivt.\n\nLämplig för: Stora, komplexa projekt där riskerna är höga och osäkerheten stor, samt för forsknings- och utvecklingsprojekt."
    },
    {
      "Diskutera för- och nackdelar med Scrum samt i vilka situationer den är mest lämplig": "Scrum är en agil metod för projektledning och utveckling som fokuserar på flexibilitet, samarbete och snabb feedback. Utvecklingen sker i korta, tidsbestämda iterationer kallade \"sprintar\", vanligtvis 1-4 veckor långa.\n\nHuvudelement: Sprintar, Sprint Backlog, Dagliga Scrums, Sprint Review, Sprint Retrospective.\n\nFördelar:\n   Flexibilitet: Mycket anpassningsbar och reagerar snabbt på förändringar.\n    Snabb feedback: Regelbundna demonstrationer (Sprint Review) ger snabb feedback från intressenter.\n   Teamfokus: Stärker teamets samarbete och motivation genom daglig kommunikation.\n   Transparens: Öppenhet i processen gör att alla vet vad som pågår.\n\nNackdelar:\n   Stora projekt: Kan vara svår att implementera i mycket stora projekt med många team som måste synkroniseras.\n    Dokumentation: Färre formella dokument skapas jämfört med Vattenfallsmodellen.\n    Teamberoende: Framgången beror mycket på teamets disciplin och kommunikationsförmåga.\n\nLämplig för: Projekt där kraven är dynamiska och kan ändras, där snabb leverans av fungerande programvara är viktig och där det finns en aktiv intressent som kan delta i processen. Detta är den vanligaste metoden för mjukvaruutveckling idag."
    },
    {
      "Du har fått följande kodsegment att testa:\n\npublic class Calculator {\n\n  public int divide(int a, int b) {\n         return a / b;\n}\n\npublic boolean isPrime(int n) {\n\nif (n <= 1) return false;\n\nfor (int i = 2; i < n; i++) {\n\nif (n % i == 0) return false;\n}\nreturn true; \n}\n}\nDesigna relevanta testfall för båda metoderna enligt principerna för black-box testing och\nmotivera kort varför du valt just detta testfall.": "| Testfall                      | Input (a, b) | Förväntat resultat              | Motivering                                           |\n| ----------------------------- | ------------ | ------------------------------- | ---------------------------------------------------- |\n| Normal division               | 10, 2        | 5                               | Vanlig division med heltal, basfall.                 |\n| Division med 1                | 7, 1         | 7                               | Kontrollera att division med 1 returnerar samma tal. |\n| Division med sig själv        | 5, 5         | 1                               | Kontrollera att a / a = 1 fungerar.                  |\n| Division med 0                | 0, 5         | 0                               | Testa noll som täljare.                              |\n| Division med noll som nämnare | 5, 0         | Exception (ArithmeticException) | Viktigt kantfall: division med 0 ger undantag.       |\n| Negativa tal                  | -10, 2       | -5                              | Testa negativt täljare.                              |\n| Negativa tal                  | 10, -2       | -5                              | Testa negativ nämnare.                               |\n| Negativa tal båda             | -10, -2      | 5                               | Kontrollera att två negativa ger positivt resultat.  |\n\n| Testfall            | Input (n) | Förväntat resultat | Motivering                                                   |\n| ------------------- | --------- | ------------------ | ------------------------------------------------------------ |\n| Negativt tal        | -5        | false              | Primtal är ≥ 2, negativa tal ska returnera false.            |\n| Noll                | 0         | false              | Noll är inte primtal.                                        |\n| Ett                 | 1         | false              | 1 är inte primtal.                                           |\n| Litet primtal       | 2         | true               | Minsta primtalet, test av kantfall.                          |\n| Litet primtal       | 3         | true               | Nästa primtal, kontrollera korrekt identifiering.            |\n| Litet icke-primtal  | 4         | false              | Kontroll av enkel icke-primtal.                              |\n| Större primtal      | 13        | true               | Testar primtal över basfallen.                               |\n| Större icke-primtal | 15        | false              | Kontroll av tal som är delbart med annat än 1 och sig själv. |\n"
    },
    {
      "Ett system har följande felfrekvenser:\n- Månad 1: 15 fel - Månad 2: 12 fel - Månad 3: 8 fel - Månad 4: 6 fel\na) Beräkna MTTF (Mean Time To Failure) för systemet": "Definition:\n\nMTTF\n=\nTotal driftstid\nAntal fel\nMTTF= \nAntal fel\nTotal driftstid\n​\n \nAntag: varje månad representerar samma tidsperiod, t.ex. 1 månad = 30 dagar.\n\nTotal antal fel:\n\n15\n+\n12\n+\n8\n+\n6\n=\n41\n fel\n15+12+8+6=41 fel\nTotal driftstid:\n\n4\n m\na\n˚\nnader\n≈\n4\n×\n30\n=\n120\n dagar\n4 m \na\n˚\n nader≈4×30=120 dagar\nMTTF:\n\nMTTF\n=\n120\n dagar\n41\n fel\n≈\n2\n,\n93\n dagar per fel\nMTTF= \n41 fel\n120 dagar\n​\n ≈2,93 dagar per fel\nSvar: MTTF ≈ 2,93 dagar"
    },
    {
      "Ett system har följande felfrekvenser:\n- Månad 1: 15 fel - Månad 2: 12 fel - Månad 3: 8 fel - Månad 4: 6 fel\nb) Vilka åtgärder skulle du rekommendera för att förbättra systemets kvalitet?\n": "Analysera felorsaker:\n\nKategorisera fel (kritiska vs mindre fel).\n\nIdentifiera mönster (moduler med flest fel).\n\nKorrigera buggar:\n\nPrioritera de fel som inträffar ofta eller påverkar användare mest.\n\nKodgranskning och testning:\n\nInför mer enhetstestning, integrationstestning och regressionstestning.\n\nFörbättra processer:\n\nInför standardiserad felhantering och versionskontroll.\n\nÖvervakning i produktion:\n\nKontinuerlig loggning och alerting för att snabbt upptäcka och fixa fel.\n\nTräning / dokumentation:\n\nSäkerställ att teamet förstår systemets design och vanliga problemområden."
    },
    {
      "Ett system har följande felfrekvenser:\n- Månad 1: 15 fel - Månad 2: 12 fel - Månad 3: 8 fel - Månad 4: 6 fel\nNär anser du att systemet är redo för produktionssättning, motivera utifrån\nkursmaterial?": "Kursmaterialets principer:\n\nSystemet anses redo för produktion när kvaliteten uppfyller kravspecifikationen och MTTF / felnivåer ligger inom acceptabel nivå.\n\nEtt system med fortlöpande minskande feltrend (som här: 15 → 6) är lovande.\n\nBedömning:\n\nOm MTTF är tillräckligt högt för att motsvara driftkraven (t.ex. systemet kan gå flera dagar utan fel) och alla kritiska fel är fixade → redo.\n\nOm vissa kritiska fel fortfarande finns → vänta tills de är åtgärdade.\n\nMotivering: MTTF har förbättrats över tiden, men systemet bör testas ytterligare för kritiska scenarier innan produktionssättning."
    },

    {
      "Beskriv Continuous Integration (CI)": "Kontinuerlig integrering av egen kod med en gemensam kodbas\nGenom att pusha kod ofta kan man snabbare se var i koden ett potentiellt fel finns\n\n"
    },
    {
      "Beskriv Daily Scrum": "Korta dagliga möten där man går igenom\nVad man har gjort sen igår,\nvad man ska göra idag &\nvilka potentiella hinder som finns\n\nDaily scrum ökar transparens och kommunikation, ger snabb identifiering av problem/hinder.\nKan bli ineffektiva möten"
    },
    {
      "Beskriv Sprint Retrospective": "Hålls i slutet av varje sprint\nVad fungerade bra?\n\nVad kan förbättras?\n\nHur genomför vi förbättringarna nästa sprint?\n\nFördelar:\nDriver kontinuerlig processförbättring.\n\nSkapar en kultur av öppenhet och lärande.\n\nBygger teamets samarbetsförmåga och förtroende.\n\nNackdelar:\nRisk för att samma problem återkommer om åtgärder inte följs upp.\n\nKan bli meningslös om deltagarna inte vågar vara ärliga.\n\nKräver tid och fokus även när projektet är pressat."
    }
  ]
}
